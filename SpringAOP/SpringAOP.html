<!DOCTYPE html>
<html lang="vi" class="scroll-smooth">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nghiên cứu Spring AOP Toàn diện</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #111827; /* gray-900 */
      color: #e5e7eb; /* gray-200 */
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Fira+Code&display=swap');

    /* Code block styling with Prism.js */
    .code-block {
      background-color: #1f2937; /* gray-800 */
      color: #e5e7eb; /* gray-200 */
      padding: 1.5rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      position: relative;
      margin-top: 1rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    .code-block pre {
      margin: 0;
      font-family: 'Fira Code', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    .copy-btn {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background-color: #4b5563; /* gray-600 */
      color: #e5e7eb;
      border: none;
      padding: 0.3rem 0.8rem;
      border-radius: 0.25rem;
      cursor: pointer;
      font-size: 0.75rem;
      transition: background-color 0.3s;
    }
    .copy-btn:hover {
      background-color: #6b7280; /* gray-500 */
    }

    /* Navigation styling */
    .nav-link {
      display: block;
      padding: 0.75rem 1.25rem;
      border-radius: 0.375rem;
      transition: all 0.3s ease;
      font-weight: 500;
      color: #e5e7eb; /* gray-200 */
    }
    .nav-link:hover {
      background-color: #374151; /* gray-700 */
    }
    .nav-link.active {
      background-color: #0ea5e9; /* sky-500 */
      color: white;
      font-weight: 600;
    }
    .sub-nav-link {
      padding-left: 2.5rem;
      font-size: 0.85rem;
      color: #9ca3af; /* gray-400 */
    }
    .sub-nav-link:hover {
      color: #0ea5e9; /* sky-500 */
    }
    .nav-toggle {
      cursor: pointer;
      font-size: 1.2rem; /* Increased size for better balance */
      font-weight: bold;
      color: #0ea5e9;
      margin-right: 0.5rem; /* Added margin for balance */
    }
    .nav-toggle:hover {
      color: #38bdf8; /* sky-400 */
    }

    /* Typography */
    h2 {
      font-size: 2rem;
      font-weight: 700;
      border-bottom: 2px solid #374151; /* gray-700 */
      padding-bottom: 0.5rem;
      margin-top: 2rem;
      margin-bottom: 1.5rem;
      color: #f9fafb; /* gray-50 */
    }
    h3 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-top: 1.75rem;
      margin-bottom: 1rem;
      color: #e5e7eb; /* gray-200 */
    }
    h4 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      color: #d1d5db; /* gray-300 */
    }
    p, li {
      line-height: 1.8;
      margin-bottom: 1rem;
    }
    .term {
      color: #0ea5e9; /* sky-500 */
      font-weight: 600;
      position: relative;
      cursor: help;
    }
    .term:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      background-color: #1f2937; /* gray-800 */
      color: #e5e7eb; /* gray-200 */
      padding: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.8rem;
      width: max-content;
      max-width: 250px;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    /* Tables */
    table {
      width: 100%;
      margin: 1.5rem 0;
      border-collapse: collapse;
      background-color: #1f2937; /* gray-800 */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    th, td {
      border: 1px solid #374151; /* gray-700 */
      padding: 1rem;
      text-align: left;
    }
    th {
      background-color: #374151; /* gray-700 */
      font-weight: 600;
      color: #e5e7eb; /* gray-200 */
    }

    /* Diagrams */
    .diagram-box {
      border: 2px solid #6b7280; /* gray-500 */
      padding: 1.25rem;
      border-radius: 0.5rem;
      text-align: center;
      background-color: #1f2937; /* gray-800 */
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease;
    }
    .diagram-box:hover {
      transform: scale(1.05);
    }
    .arrow {
      color: #9ca3af; /* gray-400 */
      font-weight: bold;
      font-size: 1.5rem;
    }
    .arrow::after {
      content: '→';
    }

    /* Accordion */
    .accordion-toggle {
      transition: background-color 0.3s ease, transform 0.2s ease;
    }
    .accordion-toggle:hover {
      background-color: #4b5563; /* gray-600 */
    }
    .accordion-content {
      transition: max-height 0.3s ease, opacity 0.3s ease;
      overflow: hidden;
    }

    /* Back to Top Button */
    .back-to-top {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background-color: #0ea5e9; /* sky-500 */
      color: white;
      padding: 0.75rem 1.25rem;
      border-radius: 0.5rem;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }
    .back-to-top:hover {
      opacity: 1;
    }
  </style>
</head>
<body class="bg-gray-900 text-gray-200">
<div class="flex min-h-screen">
  <!-- Sidebar Navigation -->
  <aside id="sidebar" class="fixed top-0 left-0 h-screen w-80 bg-gray-900 border-r border-gray-700 p-6 transition-transform -translate-x-full md:translate-x-0 overflow-y-auto z-30">
    <h1 class="text-2xl font-bold text-gray-100 mb-8">Spring AOP</h1>
    <nav id="table-of-contents">
      <ul class="space-y-2"></ul>
    </nav>
  </aside>

  <!-- Mobile Menu Button -->
  <button id="menu-toggle" class="md:hidden fixed top-4 left-4 z-40 p-3 bg-gray-900 rounded-lg shadow-lg">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke="white">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  </button>

  <!-- Main Content -->
  <main class="w-full md:ml-80 p-6 md:p-10 pt-32 md:pt-32"> <!-- Added pt-32 to account for fixed header height -->
    <header class="fixed top-0 left-0 md:left-80 right-0 bg-gray-900 py-6 mb-8 shadow-sm z-20"> <!-- Changed to fixed, adjusted positioning -->
      <h1 class="text-4xl font-extrabold text-gray-100">Nghiên cứu Spring AOP Toàn diện</h1>
      <p class="text-lg text-gray-400 mt-3">Hướng dẫn chi tiết về Lập trình hướng khía cạnh với Spring Framework, từ lý thuyết đến thực tiễn.</p>
    </header>
    <div id="content-container" class="space-y-10"></div>
    <a href="#" class="back-to-top hidden">Quay lại đầu trang</a>
  </main>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const sections = [
      {
        id: 'part1',
        title: 'PHẦN 1: NỀN TẢNG LÝ THUYẾT',
        subsections: [
          { id: 'p1_1', title: '1.1 AOP là gì?' },
          { id: 'p1_2', title: '1.2 So sánh AOP vs OOP' },
          { id: 'p1_3', title: '1.3 Core Concepts của AOP' }
        ],
        content: `
            <div id="p1_1" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>1.1 AOP là gì?</h3>
              <h4>Định nghĩa chi tiết về <span class="term" data-tooltip="Lập trình hướng khía cạnh: Một mô hình lập trình tách biệt các mối quan tâm xuyên suốt.">Aspect-Oriented Programming</span></h4>
              <p><strong>Aspect-Oriented Programming (AOP)</strong> - Lập trình hướng khía cạnh, là một mô hình lập trình (programming paradigm) nhằm mục đích tăng tính modularity bằng cách cho phép tách biệt các <strong><span class="term" data-tooltip="Các chức năng cắt ngang qua nhiều module, như logging hoặc security.">cross-cutting concerns</span></strong>. Nó thực hiện điều này bằng cách thêm hành vi bổ sung vào code hiện có mà không sửa đổi chính code đó. Thay vào đó, bạn có thể khai báo một cách riêng biệt logic sẽ được áp dụng tại các điểm cụ thể trong chương trình.</p>
              <h4>Tại sao AOP lại xuất hiện? Nó giải quyết vấn đề gì?</h4>
              <p>Lập trình hướng đối tượng (OOP) đã rất thành công trong việc modular hóa các mối quan tâm chính của ứng dụng vào các đối tượng. Tuy nhiên, có những mối quan tâm không thể gói gọn hoàn toàn trong một đối tượng duy nhất. Chúng thường "cắt ngang" qua nhiều lớp và module. Đây được gọi là <strong>Cross-cutting concerns</strong>.</p>
              <p>Ví dụ về Cross-cutting concerns:</p>
              <ul class="list-disc pl-6">
                <li><strong>Logging:</strong> Ghi log đầu vào, đầu ra, hoặc thời gian thực thi của các phương thức.</li>
                <li><strong>Security:</strong> Kiểm tra quyền truy cập trước khi thực thi một phương thức.</li>
                <li><strong>Transaction Management:</strong> Bắt đầu, commit, hoặc rollback một giao dịch.</li>
                <li><strong>Caching:</strong> Lưu trữ kết quả của các phương thức để cải thiện hiệu năng.</li>
                <li><strong>Error Handling:</strong> Xử lý ngoại lệ một cách nhất quán.</li>
              </ul>
              <p>Nếu không có AOP, logic này sẽ bị lặp lại ở nhiều nơi (code duplication) hoặc trộn lẫn với logic nghiệp vụ chính (code tangling), làm cho code khó đọc, khó bảo trì và khó phát triển.</p>
              <p>AOP cho phép chúng ta tách biệt các cross-cutting concerns này ra khỏi logic nghiệp vụ và đóng gói chúng vào các module riêng biệt gọi là <strong><span class="term" data-tooltip="Module chứa logic của cross-cutting concern.">Aspects</span></strong>. Sau đó, chúng ta có thể "dệt" (weave) các aspect này vào ứng dụng tại các điểm cần thiết một cách khai báo.</p>
            </div>

            <div id="p1_2" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>1.2 So sánh AOP vs OOP</h3>
              <h4>Điểm khác biệt cốt lõi</h4>
              <p>OOP tập trung vào việc phân rã một ứng dụng thành một hệ thống các đối tượng, mỗi đối tượng có trách nhiệm riêng. Đơn vị cơ bản của modularity là <strong>class</strong>. AOP tập trung vào việc phân rã một ứng dụng thành các khía cạnh (aspects), mỗi aspect đóng gói một cross-cutting concern. Đơn vị cơ bản của modularity là <strong>aspect</strong>.</p>
              <h4>AOP bổ sung cho OOP</h4>
              <p>AOP không phải là sự thay thế cho OOP. Nó là một công nghệ bổ sung. Bạn vẫn thiết kế ứng dụng của mình theo nguyên tắc OOP, sau đó sử dụng AOP để giải quyết các cross-cutting concerns mà OOP không xử lý tốt. Sự kết hợp này tạo ra một hệ thống sạch sẽ và modular hơn.</p>
              <h4>Ví dụ: Cùng một bài toán</h4>
              <p><strong>Bài toán:</strong> Đo thời gian thực thi của một phương thức dịch vụ.</p>
              <h4>Giải pháp OOP thuần (sử dụng Decorator Pattern)</h4>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
// Interface
public interface ProductService {
    void findProduct(String id);
}

// Implementation
public class ProductServiceImpl implements ProductService {
    @Override
    public void findProduct(String id) {
        // Business logic...
        System.out.println("Finding product with id: " + id);
    }
}

// Decorator for logging execution time
public class ProductServiceProfiler implements ProductService {
    private final ProductService target;

    public ProductServiceProfiler(ProductService target) {
        this.target = target;
    }

    @Override
    public void findProduct(String id) {
        long start = System.currentTimeMillis();
        target.findProduct(id);
        long end = System.currentTimeMillis();
        System.out.println("Execution time: " + (end - start) + "ms");
    }
}

// Usage
ProductService service = new ProductServiceImpl();
ProductService profiledService = new ProductServiceProfiler(service);
profiledService.findProduct("123");
                </code></pre>
              </div>
              <p class="mt-3 italic">Nhược điểm: Phải tạo class decorator, và client code phải biết để sử dụng instance của decorator thay vì implementation gốc.</p>
              <h4>Giải pháp OOP + AOP</h4>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
// Service (không thay đổi)
@Service
public class ProductService {
    public void findProduct(String id) {
        // Business logic...
        System.out.println("Finding product with id: " + id);
    }
}

// Aspect for performance monitoring
@Aspect
@Component
public class PerformanceMonitorAspect {

    @Around("execution(* com.example.service.ProductService.findProduct(..))")
    public Object profile(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();
        System.out.println("Execution time for " + joinPoint.getSignature().getName() + ": " + (end - start) + "ms");
        return result;
    }
}

// Usage (không thay đổi, Spring sẽ tự động áp dụng aspect)
@Autowired
private ProductService productService;

public void someMethod() {
    productService.findProduct("123");
}
                </code></pre>
              </div>
              <p class="mt-3 italic">Ưu điểm: Hoàn toàn tách biệt. <code>ProductService</code> không hề biết về việc nó đang được giám sát hiệu năng. Logic giám sát được tập trung tại một nơi duy nhất và có thể dễ dàng áp dụng cho các phương thức khác.</p>
            </div>

            <div id="p1_3" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>1.3 Core Concepts của AOP</h3>
              <p>Để hiểu AOP, bạn cần nắm vững các khái niệm cốt lõi sau. Chúng ta có thể hình dung mối quan hệ của chúng qua sơ đồ sau:</p>
              <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-6 my-8">
                <div class="diagram-box">
                  <h4 class="mt-0 font-bold">Aspect</h4>
                  <p class="text-sm">Module chứa Advices và Pointcuts</p>
                </div>
                <div class="arrow"></div>
                <div class="diagram-box">
                  <h4 class="mt-0 font-bold">Advice</h4>
                  <p class="text-sm">Hành động cần thực thi (WHAT, HOW)</p>
                </div>
                <div class="arrow"></div>
                <div class="diagram-box">
                  <h4 class="mt-0 font-bold">Pointcut</h4>
                  <p class="text-sm">Nơi thực thi Advice (WHERE)</p>
                </div>
              </div>
              <p>Chi tiết các khái niệm:</p>
              <ul class="list-disc pl-6">
                <li><strong><span class="term" data-tooltip="Module chứa logic của cross-cutting concern.">Aspect</span>:</strong> Là một module (một class trong Spring AOP) đóng gói các <strong>advices</strong> và <strong>pointcuts</strong>. Nó định nghĩa một cross-cutting concern hoàn chỉnh. Ví dụ: một aspect cho logging, một aspect cho transaction.</li>
                <li><strong><span class="term" data-tooltip="Điểm cụ thể trong chương trình, như khi một phương thức được gọi.">Join Point</span>:</strong> Là một điểm cụ thể trong quá trình thực thi chương trình. Trong Spring AOP, một join point luôn là việc thực thi một phương thức (method execution).</li>
                <li><strong><span class="term" data-tooltip="Hành động được thực hiện tại một join point.">Advice</span>:</strong> Là hành động được thực hiện bởi một aspect tại một join point cụ thể. Có nhiều loại advice: before, after, around... Advice trả lời câu hỏi "WHAT to do" và "WHEN to do it".</li>
                <li><strong><span class="term" data-tooltip="Biểu thức xác định nơi áp dụng advice.">Pointcut</span>:</strong> Là một biểu thức (expression) khớp với các join points. Pointcut định nghĩa nơi một advice sẽ được áp dụng. Pointcut trả lời câu hỏi "WHERE to do it".</li>
                <li><strong><span class="term" data-tooltip="Thêm phương thức hoặc thuộc tính mới vào class hiện có.">Introduction</span>:</strong> Cho phép thêm các phương thức hoặc thuộc tính mới vào các class hiện có.</li>
                <li><strong><span class="term" data-tooltip="Đối tượng được aspect tác động.">Target Object</span>:</strong> Là đối tượng mà một hoặc nhiều aspect đang "advise" (áp dụng advice). Nó còn được gọi là "advised object".</li>
                <li><strong><span class="term" data-tooltip="Đối tượng bao bọc target object để áp dụng aspect.">AOP Proxy</span>:</strong> Là một đối tượng được tạo bởi AOP framework (Spring) để triển khai các aspect contract. Trong Spring AOP, proxy là một JDK dynamic proxy hoặc một CGLIB proxy. Nó sẽ bao bọc Target Object.</li>
                <li><strong><span class="term" data-tooltip="Quá trình liên kết aspect với target object.">Weaving</span>:</strong> Là quá trình liên kết các aspect với các target object để tạo ra advised object (proxy). Weaving có thể xảy ra tại compile time, load time, hoặc runtime. Spring AOP thực hiện weaving tại <strong>runtime</strong>.</li>
              </ul>
            </div>
          `
      },
      {
        id: 'part2',
        title: 'PHẦN 2: SPRING AOP CỤ THỂ',
        subsections: [
          { id: 'p2_1', title: '2.1 Spring AOP Overview' },
          { id: 'p2_2', title: '2.2 Cách Spring AOP hoạt động' },
          { id: 'p2_3', title: '2.3 Các loại Advice' },
          { id: 'p2_4', title: '2.4 Pointcut Expressions' }
        ],
        content: `
            <div id="p2_1" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>2.1 Spring AOP Overview</h3>
              <h4>Spring AOP khác gì với AspectJ thuần?</h4>
              <p>Spring AOP được xây dựng để cung cấp các giải pháp AOP cơ bản cho các vấn đề phổ biến trong ứng dụng Spring, đặc biệt là các cross-cutting concerns như transaction management, security. Nó đơn giản hơn và dễ sử dụng hơn AspectJ.</p>
              <table>
                <thead>
                  <tr>
                    <th>Tính năng</th>
                    <th>Spring AOP</th>
                    <th>AspectJ</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Mục tiêu</td>
                    <td>Giải quyết các vấn đề phổ biến trong Spring. Đơn giản và đủ dùng.</td>
                    <td>Một giải pháp AOP hoàn chỉnh và mạnh mẽ.</td>
                  </tr>
                  <tr>
                    <td>Weaving</td>
                    <td>Runtime Weaving (thông qua proxies).</td>
                    <td>Compile-time hoặc Load-time Weaving (thao tác bytecode).</td>
                  </tr>
                  <tr>
                    <td>Join Points</td>
                    <td>Chỉ hỗ trợ method execution join points.</td>
                    <td>Hỗ trợ nhiều loại join points (method execution, method call, field access, constructor execution...).</td>
                  </tr>
                  <tr>
                    <td>Độ phức tạp</td>
                    <td>Dễ học và sử dụng. Không cần công cụ đặc biệt.</td>
                    <td>Phức tạp hơn, yêu cầu compiler riêng (ajc).</td>
                  </tr>
                </tbody>
              </table>
              <p><strong>Lựa chọn khi nào?</strong> Sử dụng Spring AOP cho hầu hết các trường hợp trong ứng dụng Spring. Chỉ cần đến AspectJ khi bạn cần advise các join points không được Spring AOP hỗ trợ (như constructor hoặc field) hoặc cần hiệu năng cao hơn bằng compile-time weaving.</p>
              <h4>JDK Dynamic Proxy vs CGLIB Proxy</h4>
              <p>Spring AOP sử dụng một trong hai cơ chế để tạo proxy tại runtime:</p>
              <ul class="list-disc pl-6">
                <li><strong>JDK Dynamic Proxy:</strong> Là cơ chế chuẩn của Java. Nó chỉ có thể tạo proxy cho các <strong>interfaces</strong>. Nếu target class của bạn implement ít nhất một interface, Spring sẽ mặc định sử dụng JDK proxy.</li>
                <li><strong>CGLIB Proxy:</strong> Là một thư viện bên thứ ba. Nó tạo proxy bằng cách tạo một <strong>subclass</strong> của target class tại runtime. Do đó, nó có thể proxy các class không implement interface. Tuy nhiên, nó không thể proxy các phương thức <code>final</code> hoặc <code>private</code>.</li>
              </ul>
              <p>Trong Spring Boot, CGLIB là mặc định ngay cả khi bạn có interface. Bạn có thể thay đổi hành vi này bằng cách set thuộc tính <code>spring.aop.proxy-target-class=false</code>.</p>
            </div>
            <div id="p2_2" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>2.2 Cách Spring AOP hoạt động under the hood</h3>
              <p>Quá trình AOP trong Spring diễn ra khi Spring container khởi tạo các beans. Đây là một flow đơn giản:</p>
              <div class="bg-gray-900 p-6 rounded-lg shadow-md my-6">
                <div class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0 md:space-x-4">
                  <div class="text-center">
                    <div class="text-xl font-bold bg-sky-900 text-sky-200 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3">1</div>
                    <p>Spring Container quét các beans.</p>
                  </div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="text-center">
                    <div class="text-xl font-bold bg-sky-900 text-sky-200 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3">2</div>
                    <p>Tìm thấy các Aspects (@Aspect) và Pointcuts.</p>
                  </div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="text-center">
                    <div class="text-xl font-bold bg-sky-900 text-sky-200 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3">3</div>
                    <p>Kiểm tra xem bean có khớp với Pointcut nào không.</p>
                  </div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="text-center">
                    <div class="text-xl font-bold bg-sky-900 text-sky-200 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3">4</div>
                    <p>Nếu khớp, Spring tạo một <strong>Proxy Object</strong>.</p>
                  </div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="text-center">
                    <div class="text-xl font-bold bg-sky-900 text-sky-200 rounded-full w-12 h-12 flex items-center justify-center mx-auto mb-3">5</div>
                    <p>Proxy được đưa vào container thay cho bean gốc.</p>
                  </div>
                </div>
              </div>
              <p>Khi một phương thức trên proxy được gọi:</p>
              <ol class="list-decimal pl-6">
                <li>Proxy chặn cuộc gọi.</li>
                <li>Nó thực thi logic của các <strong>advices</strong> tương ứng (before, after...).</li>
                <li>Cuối cùng, nó ủy quyền cuộc gọi đến phương thức tương ứng trên <strong>target object</strong>.</li>
              </ol>
              <p><strong>Performance implications:</strong> Vì có thêm một lớp proxy, sẽ có một chút overhead về hiệu năng. Tuy nhiên, trong hầu hết các ứng dụng, overhead này là không đáng kể so với lợi ích về kiến trúc và bảo trì. CGLIB thường nhanh hơn một chút so với JDK proxy.</p>
            </div>
            <div id="p2_3" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>2.3 Các loại Advice trong Spring AOP</h3>
              <p>Spring AOP cung cấp 5 loại advice, mỗi loại phục vụ một mục đích khác nhau. Thứ tự thực thi của chúng quanh một join point (method execution) là rất quan trọng.</p>
              <div class="relative p-6 my-6 border-2 border-dashed border-gray-600 rounded-lg">
                <div class="text-center font-bold text-lg mb-4">Method Execution Flow</div>
                <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4">
                  <div class="diagram-box bg-lime-900 border-lime-600">@Before</div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="diagram-box bg-amber-900 border-amber-600 flex flex-col items-center justify-center space-y-2">
                    <div>@Around (before proceed)</div>
                    <div class="diagram-box bg-sky-900 border-sky-600">Target Method</div>
                    <div>@Around (after proceed)</div>
                  </div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="flex flex-col space-y-2">
                    <div class="diagram-box bg-green-900 border-green-600">@AfterReturning</div>
                    <div class="diagram-box bg-red-900 border-red-600">@AfterThrowing</div>
                  </div>
                  <div class="arrow hidden md:flex"></div>
                  <div class="diagram-box bg-indigo-900 border-indigo-600">@After</div>
                </div>
              </div>
              <h4>@Before</h4>
              <p>Thực thi <strong>trước khi</strong> join point được thực thi. Thường dùng để kiểm tra điều kiện, ghi log đầu vào, hoặc kiểm tra an ninh.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@Before("execution(* com.example.service.*.*(..))")
public void logMethodEntry(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    Object[] args = joinPoint.getArgs();
    log.info("Entering method: {} with arguments: {}", methodName, args);
}
                </code></pre>
              </div>
              <h4>@After</h4>
              <p>Thực thi <strong>sau khi</strong> join point hoàn thành, bất kể nó kết thúc bình thường hay ném ra một ngoại lệ. Thường dùng để giải phóng tài nguyên (resource cleanup).</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@After("execution(* com.example.repository.*.*(..))")
public void releaseConnection(JoinPoint joinPoint) {
    log.info("Releasing resources after method: {}", joinPoint.getSignature().getName());
}
                </code></pre>
              </div>
              <h4>@AfterReturning</h4>
              <p>Thực thi <strong>chỉ khi</strong> join point hoàn thành một cách bình thường (không ném ra ngoại lệ). Có thể truy cập vào giá trị trả về của phương thức.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@AfterReturning(
    pointcut = "execution(* com.example.service.ProductService.findProductById(..))",
    returning = "result"
)
public void logMethodReturn(JoinPoint joinPoint, Object result) {
    log.info("Method {} returned with value: {}", joinPoint.getSignature().getName(), result);
}
                </code></pre>
              </div>
              <h4>@AfterThrowing</h4>
              <p>Thực thi <strong>chỉ khi</strong> join point kết thúc bằng cách ném ra một ngoại lệ. Có thể truy cập vào ngoại lệ đó. Thường dùng cho việc xử lý lỗi tập trung.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@AfterThrowing(
    pointcut = "execution(* com.example.service.*.*(..))",
    throwing = "exception"
)
public void handleException(JoinPoint joinPoint, Throwable exception) {
    log.error("Exception in method {}: {}", joinPoint.getSignature().getName(), exception.getMessage());
    // Ví dụ: gửi thông báo đến hệ thống giám sát
}
                </code></pre>
              </div>
              <h4>@Around</h4>
              <p>Advice mạnh mẽ nhất. Nó "bao bọc" xung quanh một join point. Nó cho phép bạn thực thi logic cả trước và sau khi join point được thực thi. Nó cũng có khả năng quyết định có thực thi join point hay không, hoặc sửa đổi các tham số đầu vào và giá trị trả về. Đây là advice duy nhất có kiểu trả về và phải nhận <code>ProceedingJoinPoint</code> làm tham số. Bạn phải gọi <code>joinPoint.proceed()</code> để thực thi phương thức gốc.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@Around("execution(* com.example.service.*.*(..))")
public Object profileExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.currentTimeMillis();
    log.info("Starting execution of {}", joinPoint.getSignature().getName());

    Object result = joinPoint.proceed(); // Thực thi phương thức gốc

    long executionTime = System.currentTimeMillis() - start;
    log.info("{} executed in {}ms", joinPoint.getSignature().getName(), executionTime);

    return result;
}
                </code></pre>
              </div>
              <p class="mt-3"><strong>Use cases:</strong> Caching, transaction management, performance monitoring, retry logic.</p>
            </div>
            <div id="p2_4" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>2.4 Pointcut Expressions chi tiết</h3>
              <p>Pointcut expression là một chuỗi xác định các join point mà advice sẽ được áp dụng. Spring AOP sử dụng ngôn ngữ biểu thức của AspectJ.</p>
              <h4><code>execution()</code></h4>
              <p>Đây là designator phổ biến nhất. Nó khớp với việc thực thi phương thức.</p>
              <p>Cú pháp: <code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</code></p>
              <ul class="list-disc pl-6">
                <li><code>?</code> có nghĩa là optional.</li>
                <li><code>*</code> là wildcard cho một phần tử (kiểu trả về, tên...).</li>
                <li><code>..</code> là wildcard cho nhiều phần tử (trong package, trong danh sách tham số).</li>
              </ul>
              <p>Ví dụ:</p>
              <ul class="list-disc pl-6">
                <li><code>execution(public * com.example.service.AccountService.*(..))</code>: Mọi phương thức public trong class <code>AccountService</code>.</li>
                <li><code>execution(* com.example.service.*.*(..))</code>: Mọi phương thức trong mọi class của package <code>com.example.service</code>.</li>
                <li><code>execution(* com.example..*.*(..))</code>: Mọi phương thức trong package <code>com.example</code> và các sub-packages của nó.</li>
              </ul>
              <h4><code>within()</code></h4>
              <p>Giới hạn khớp với các join points trong một kiểu (class hoặc interface) nhất định.</p>
              <p>Ví dụ: <code>within(com.example.service.ProductService)</code>: Mọi join point trong class <code>ProductService</code>.</p>
              <p><code>within(com.example.service.*)</code>: Mọi join point trong bất kỳ class nào của package <code>service</code>.</p>
              <h4><code>@annotation()</code></h4>
              <p>Khớp với các join points nơi phương thức thực thi có một annotation cụ thể.</p>
              <p>Ví dụ: <code>@annotation(com.example.annotations.Loggable)</code>: Khớp với bất kỳ phương thức nào được chú thích bằng <code>@Loggable</code>.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
// Custom annotation
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {}

// Aspect
@Before("@annotation(com.example.annotations.Loggable)")
public void logBefore() { ... }

// Service
@Service
public class MyService {
    @Loggable
    public void doSomething() { ... }
}
                </code></pre>
              </div>
              <h4>Kết hợp Pointcuts</h4>
              <p>Bạn có thể kết hợp các biểu thức pointcut bằng cách sử dụng <code>&&</code> (AND), <code>||</code> (OR), và <code>!</code> (NOT).</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@Pointcut("within(com.example.web..*)")
private void inWebLayer() {}

@Pointcut("execution(* com.example.service.*.*(..))")
private void inServiceLayer() {}

// Áp dụng advice cho cả hai layer
@Before("inWebLayer() || inServiceLayer()")
public void logLayers() { ... }
                </code></pre>
              </div>
            </div>
          `
      },
      {
        id: 'part3',
        title: 'PHẦN 3: IMPLEMENTATION & CODE EXAMPLES',
        subsections: [
          { id: 'p3_1', title: '3.1 Setup và Configuration' },
          { id: 'p3_2', title: '3.2 Real-world Use Cases' }
        ],
        content: `
            <div id="p3_1" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>3.1 Setup và Configuration</h3>
              <h4>Maven Dependency</h4>
              <p>Để sử dụng Spring AOP, bạn cần dependency <code>spring-boot-starter-aop</code>.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
                </code></pre>
              </div>
              <p>Starter này sẽ tự động kéo theo <code>spring-aop</code> và <code>aspectjweaver</code>.</p>
              <h4>Bật AOP Proxy</h4>
              <p>Trong một ứng dụng Spring Boot, chỉ cần có starter <code>spring-boot-starter-aop</code> là AOP đã được tự động cấu hình. Spring Boot sẽ tự động thêm annotation <code>@EnableAspectJAutoProxy</code>.</p>
              <p>Nếu không dùng Spring Boot, bạn cần thêm <code>@EnableAspectJAutoProxy</code> vào một class configuration của mình.</p>
              <div class="code-block">
                <button class="copy-btn">Copy</button>
                <pre><code class="language-java">
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
    // ...
}
                </code></pre>
              </div>
            </div>
            <div id="p3_2" class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>3.2 Real-world Use Cases với code đầy đủ</h3>
              <p>Dưới đây là một số ví dụ thực tế về cách áp dụng AOP. Mỗi ví dụ là một collapsible section.</p>
              <div class="space-y-4" data-accordion>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>Logging Aspect</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p>Đây là một trong những ứng dụng phổ biến nhất. Aspect này sẽ ghi log chi tiết về việc thực thi các phương thức trong layer service và repository.</p>
                      <div class="code-block">
                        <button class="copy-btn">Copy</button>
                        <pre><code class="language-java">
@Aspect
@Component
@Slf4j // Lombok annotation for logger
public class LoggingAspect {

    @Pointcut("within(@org.springframework.stereotype.Repository *)" +
        " || within(@org.springframework.stereotype.Service *)" +
        " || within(@org.springframework.web.bind.annotation.RestController *)")
    public void springBeanPointcut() {
    }

    @Around("springBeanPointcut()")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        log.info("Enter: {}.{}() with argument[s] = {}",
            joinPoint.getSignature().getDeclaringTypeName(),
            joinPoint.getSignature().getName(),
            Arrays.toString(joinPoint.getArgs()));

        try {
            Object result = joinPoint.proceed();
            log.info("Exit: {}.{}() with result = {}",
                joinPoint.getSignature().getDeclaringTypeName(),
                joinPoint.getSignature().getName(),
                result);
            return result;
        } catch (IllegalArgumentException e) {
            log.error("Illegal argument: {} in {}.{}()",
                Arrays.toString(joinPoint.getArgs()),
                joinPoint.getSignature().getDeclaringTypeName(),
                joinPoint.getSignature().getName());
            throw e;
        }
    }
}
                        </code></pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>Security Aspect</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p>Sử dụng AOP để kiểm tra quyền của người dùng trước khi thực thi một phương thức. Chúng ta sẽ tạo một custom annotation <code>@CheckRole</code>.</p>
                      <div class="code-block">
                        <button class="copy-btn">Copy</button>
                        <pre><code class="language-java">
// Annotation
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CheckRole {
    String value();
}

// Aspect
@Aspect
@Component
public class SecurityAspect {

    @Before("@annotation(checkRole)")
    public void checkRole(CheckRole checkRole) {
        // Giả sử có một SecurityContext để lấy thông tin user hiện tại
        User currentUser = SecurityContext.getCurrentUser();

        if (currentUser == null || !currentUser.getRoles().contains(checkRole.value())) {
            throw new SecurityException("Access Denied: Required role '" + checkRole.value() + "'");
        }
    }
}

// Usage in a Controller
@RestController
public class AdminController {

    @GetMapping("/admin/data")
    @CheckRole("ADMIN")
    public String getAdminData() {
        return "Sensitive admin data";
    }
}
                        </code></pre>
                      </div>
                    </div>
                  </div>
                </div>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>Performance Monitoring</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p>Tự động theo dõi thời gian thực thi của các phương thức và cảnh báo nếu một phương thức chạy quá chậm.</p>
                      <div class="code-block">
                        <button class="copy-btn">Copy</button>
                        <pre><code class="language-java">
@Aspect
@Component
@Slf4j
public class PerformanceAspect {
    private static final long SLOW_METHOD_THRESHOLD_MS = 1000;

    @Around("execution(* com.example.service..*(..))")
    public Object measureExecutionTime(ProceedingJoinPoint pjp) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = pjp.proceed();
        long executionTime = System.currentTimeMillis() - start;

        if (executionTime > SLOW_METHOD_THRESHOLD_MS) {
            log.warn("SLOW METHOD: {} executed in {} ms", pjp.getSignature(), executionTime);
        }
        return result;
    }
}
                        </code></pre>
                      </div>
                      <h4 class="mt-4">Biểu đồ so sánh Performance Overhead</h4>
                      <p>Mặc dù overhead của AOP thường nhỏ, nhưng nó vẫn tồn tại. Biểu đồ dưới đây minh họa sự khác biệt tương đối về overhead khi thực hiện một số lượng lớn các lời gọi phương thức được proxy bằng JDK và CGLIB. CGLIB thường có overhead khởi tạo cao hơn nhưng overhead trên mỗi lời gọi thấp hơn.</p>
                      <div class="chart-container h-80 w-full max-w-xl mx-auto my-6">
                        <canvas id="performanceChart"></canvas>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          `
      },
      {
        id: 'part9',
        title: 'PHẦN 9: INTERVIEW QUESTIONS',
        content: `
            <div class="bg-gray-900 p-6 rounded-lg shadow-md">
              <h3>Top 10 câu hỏi phỏng vấn về Spring AOP</h3>
              <p>Dưới đây là danh sách các câu hỏi thường gặp về Spring AOP, từ cơ bản đến nâng cao. Nhấp vào câu hỏi để xem câu trả lời.</p>
              <div class="space-y-4" data-accordion>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>1. AOP là gì và nó giải quyết vấn đề gì?</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p><strong>Trả lời:</strong> AOP (Aspect-Oriented Programming) là một mô hình lập trình cho phép tách biệt các mối quan tâm xuyên suốt (cross-cutting concerns) như logging, security, transaction management... ra khỏi logic nghiệp vụ chính. Nó giải quyết vấn đề code bị lặp lại (code duplication) và code bị rối (code tangling), giúp mã nguồn trở nên sạch sẽ, modular và dễ bảo trì hơn.</p>
                    </div>
                  </div>
                </div>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>2. Sự khác biệt giữa Spring AOP và AspectJ là gì?</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p><strong>Trả lời:</strong></p>
                      <ul class="list-disc pl-6">
                        <li><strong>Spring AOP:</strong> Sử dụng runtime weaving thông qua proxy (JDK Dynamic Proxy hoặc CGLIB). Nó đơn giản hơn và chỉ hỗ trợ method execution join points. Nó được tích hợp sẵn và đủ dùng cho hầu hết các trường hợp trong Spring.</li>
                        <li><strong>AspectJ:</strong> Là một framework AOP hoàn chỉnh, mạnh mẽ hơn. Nó sử dụng compile-time hoặc load-time weaving (thao tác bytecode trực tiếp). Nó hỗ trợ nhiều loại join points hơn (field access, constructor execution...).</li>
                      </ul>
                    </div>
                  </div>
                </div>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>3. Giải thích các khái niệm: Aspect, Join Point, Advice, Pointcut.</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <ul class="list-disc pl-6">
                        <li><strong>Aspect:</strong> Một module (class) chứa logic cho một cross-cutting concern.</li>
                        <li><strong>Join Point:</strong> Một điểm trong quá trình thực thi chương trình, ví dụ như một method execution.</li>
                        <li><strong>Advice:</strong> Hành động (logic) được thực hiện bởi một Aspect tại một Join Point. Có 5 loại: Before, After, AfterReturning, AfterThrowing, Around.</li>
                        <li><strong>Pointcut:</strong> Một biểu thức để chọn ra các Join Points mà Advice sẽ được áp dụng.</li>
                      </ul>
                    </div>
                  </div>
                </div>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>4. @Around advice khác gì so với các advice khác?</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p><strong>Trả lời:</strong> <code>@Around</code> là advice mạnh mẽ nhất. Nó "bao bọc" hoàn toàn một join point. Nó có thể:</p>
                      <ul class="list-disc pl-6">
                        <li>Thực thi logic cả trước và sau khi phương thức gốc chạy.</li>
                        <li>Quyết định có chạy phương thức gốc hay không bằng cách gọi (hoặc không gọi) <code>ProceedingJoinPoint.proceed()</code>.</li>
                        <li>Sửa đổi các tham số đầu vào hoặc giá trị trả về của phương thức gốc.</li>
                      </ul>
                      <p>Các advice khác không có khả năng này.</p>
                    </div>
                  </div>
                </div>
                <div>
                  <button class="accordion-toggle w-full text-left p-4 bg-gray-700 rounded-lg font-bold flex justify-between items-center">
                    <span>5. Vấn đề "self-invocation" trong Spring AOP là gì và tại sao nó xảy ra?</span>
                    <span class="transform transition-transform duration-200">+</span>
                  </button>
                  <div class="accordion-content max-h-0 opacity-0">
                    <div class="p-4 bg-gray-900 border border-t-0 border-gray-700 rounded-b-lg">
                      <p><strong>Trả lời:</strong> Vấn đề self-invocation xảy ra khi một phương thức có áp dụng aspect gọi một phương thức khác trong cùng một class. Lời gọi nội bộ này không đi qua proxy mà gọi trực tiếp phương thức trên đối tượng <code>this</code> (target object). Do đó, aspect sẽ không được áp dụng cho lời gọi thứ hai.</p>
                      <p><strong>Ví dụ:</strong></p>
                      <div class="code-block">
                        <pre><code class="language-java">
@Service
public class MyService {
    @Transactional
    public void methodA() {
        // ... some logic
        this.methodB(); // Aspect trên methodB sẽ KHÔNG được áp dụng
    }

    @Transactional
    public void methodB() {
        // ... some logic
    }
}
                        </code></pre>
                      </div>
                      <p><strong>Cách giải quyết:</strong> Tự inject bean vào chính nó, hoặc tách phương thức thứ hai ra một bean khác.</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          `
      },
    ];

    const toc = document.getElementById('table-of-contents').querySelector('ul');
    const contentContainer = document.getElementById('content-container');

    sections.forEach(section => {
      const li = document.createElement('li');
      li.innerHTML = `
          <div class="flex items-center justify-between">
            <a href="#${section.id}" class="nav-link">${section.title}</a>
            ${section.subsections ? '<span class="nav-toggle">+</span>' : ''}
          </div>
        `;
      const sectionDiv = document.createElement('section');
      sectionDiv.id = section.id;
      sectionDiv.innerHTML = `<h2>${section.title}</h2>${section.content}`;
      contentContainer.appendChild(sectionDiv);

      if (section.subsections) {
        const subUl = document.createElement('ul');
        subUl.classList.add('hidden', 'mt-2', 'space-y-1');
        section.subsections.forEach(sub => {
          const subLi = document.createElement('li');
          subLi.innerHTML = `<a href="#${sub.id}" class="nav-link sub-nav-link">${sub.title}</a>`;
          subUl.appendChild(subLi);
        });
        li.appendChild(subUl);
        li.querySelector('.nav-toggle').addEventListener('click', () => {
          subUl.classList.toggle('hidden');
          li.querySelector('.nav-toggle').textContent = subUl.classList.contains('hidden') ? '+' : '-';
        });
      }
      toc.appendChild(li);
    });

    function initAccordions() {
      document.querySelectorAll('[data-accordion]').forEach(accordion => {
        accordion.querySelectorAll('.accordion-toggle').forEach(toggle => {
          toggle.addEventListener('click', () => {
            const content = toggle.nextElementSibling;
            const icon = toggle.querySelector('span:last-child');
            if (content.classList.contains('max-h-0')) {
              content.classList.remove('max-h-0', 'opacity-0');
              content.classList.add('max-h-screen', 'opacity-100');
              icon.textContent = '-';
            } else {
              content.classList.remove('max-h-screen', 'opacity-100');
              content.classList.add('max-h-0', 'opacity-0');
              icon.textContent = '+';
            }
          });
        });
      });
    }

    function initCopyButtons() {
      document.querySelectorAll('.copy-btn').forEach(button => {
        button.addEventListener('click', () => {
          const code = button.nextElementSibling.textContent;
          navigator.clipboard.writeText(code).then(() => {
            button.textContent = 'Copied!';
            setTimeout(() => button.textContent = 'Copy', 2000);
          });
        });
      });
    }

    function createPerformanceChart() {
      const ctx = document.getElementById('performanceChart');
      if (!ctx) return;
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['JDK Dynamic Proxy', 'CGLIB Proxy'],
          datasets: [{
            label: 'Overhead per 1M Calls (ms)',
            data: [120, 95],
            backgroundColor: ['rgba(54, 162, 235, 0.6)', 'rgba(75, 192, 192, 0.6)'],
            borderColor: ['rgba(54, 162, 235, 1)', 'rgba(75, 192, 192, 1)'],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Relative Overhead (ms)',
                font: { size: 14 },
                color: '#e5e7eb' /* gray-200 */
              },
              ticks: {
                color: '#e5e7eb' /* gray-200 */
              },
              grid: {
                color: '#374151' /* gray-700 */
              }
            },
            x: {
              title: {
                display: true,
                text: 'Proxy Type',
                font: { size: 14 },
                color: '#e5e7eb' /* gray-200 */
              },
              ticks: {
                color: '#e5e7eb' /* gray-200 */
              },
              grid: {
                color: '#374151' /* gray-700 */
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: 'AOP Proxy Performance Comparison',
              font: { size: 16 },
              color: '#e5e7eb' /* gray-200 */,
              padding: { top: 10, bottom: 20 }
            },
            tooltip: {
              callbacks: {
                label: context => `${context.dataset.label}: ${context.parsed.y}ms`
              },
              backgroundColor: '#1f2937', /* gray-800 */
              titleColor: '#e5e7eb', /* gray-200 */
              bodyColor: '#e5e7eb' /* gray-200 */
            }
          }
        }
      });
    }

    function initBackToTop() {
      const backToTop = document.querySelector('.back-to-top');
      window.addEventListener('scroll', () => {
        backToTop.classList.toggle('hidden', window.scrollY < 300);
      });
    }

    const menuToggle = document.getElementById('menu-toggle');
    const sidebar = document.getElementById('sidebar');
    menuToggle.addEventListener('click', () => {
      sidebar.classList.toggle('-translate-x-full');
    });

    const navLinks = document.querySelectorAll('.nav-link');
    const contentSections = document.querySelectorAll('main section');
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('id');
          navLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('href') === `#${id}`) {
              link.classList.add('active');
            }
          });
        }
      });
    }, { rootMargin: '-20% 0px -80% 0px' });

    contentSections.forEach(section => observer.observe(section));
    initAccordions();
    initCopyButtons();
    createPerformanceChart();
    initBackToTop();
    Prism.highlightAll();
  });
</script>
</body>
</html>